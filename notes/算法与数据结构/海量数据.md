七．海量数据
============

7.1 几种数据结构和算法
----------------------

**HashMap：**对于同一个键，哈希出来的值一定是一样的，但是不同的键哈希出来也可能一样，这就是发生了冲突（或碰撞）。

**BitMap：**可以看成是bit数组，数组的每个位置只有0或1两种状态。Java中可以使用int数组表示位图，arr[0]是一个int，一个int是32位，故可以表示0-31的数，同理arr[1]可表示32-63...实际上就是用一个32位整型表示了32个数。

**大/小根堆：**O(1)时间可在堆顶得到最大值/最小值。利用小根堆可用于求Top K问题。

**布隆过滤器：**使用长度为m的bit数组和k个Hash函数，某个键经过k个哈希函数得到k个下标，将k个下标在bit数组中对应的位置设置为1。对于每个键都重复上述过程，得到最终设置好的布隆过滤器。对于新来的键，使用同样的过程，得到k个下标，判断k个下标在bit数组中的值是否为1，若有一个不为1，说明这个键一定不在集合中。若全为1，也可能不在集合中。**就是说：查询某个键，判断不属于该集合是绝对正确的；判断属于该集合是低概率错误的。因为多个位置的1可能是由不同的键散列得到。**误报率和m的大小有关：m越小，误报率越高。利用布隆过滤器来加速查找和判断是否存在。HashMap的问题在于存储容量占比高。

7.2 分而治之/Hash映射+Hash_map统计+堆/快速/归并排序
---------------------------------------------------

既然是海量数据处理，那么可想而知，给的数据那就一定是海量的。针对这个数据的海量，可以进行**分而治之/hash映射
+ hash统计 +
堆/快速/归并排序**这个过程，说白了，就是先映射，而后统计，最后排序：

**分而治之/hash映射：**针对数据太大，内存受限，只能是把大文件化成(取模映射)小文件。

**hash_map统计：**当大文件转化了小文件，那么便可以采用常规的hash_map(ip，value)来进行频率统计。

**堆/快速排序**：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。

**问题1：海量日志数据，提取出某日访问百度次数最多的那个IP。**

具体而论，则是：首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2\^32个IP。同样可以采用映射的方法，比如%1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map对那1000个文件中的所有IP进行频率统计，然后依次找出各个文件中频率最大的那个IP）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。

**关于本题，还有几个问题，如下**：

1、Hash取模是一种等价映射，不会存在同一个元素分散到不同小文件中的情况，即这里采用的是mod1000算法，那么相同的IP在hash取模后，只可能落在同一个文件中，不可能被分散的。因为如果两个IP相等，那么经过Hash(IP)之后的哈希值是相同的，将此哈希值取模（如模1000），必定仍然相等。

2、那到底什么是hash映射呢？简单来说，就是为了便于计算机在有限的内存中处理大数据，从而通过一种映射散列的方式让数据均匀分布在对应的内存位置(如大数据通过取余的方式映射成小树存放在内存中，或大文件映射成多个小文件)，而这个映射散列方式便是通常所说的hash函数，设计的好的hash函数能让数据均匀分布而减少冲突。尽管数据映射到了另外一些不同的位置，但数据还是原来的数据，只是代替和表示这些原始数据的形式发生了变化而已。

**问题2：寻找热门查询，300万个查询字符串中统计最热门的10个查询**

原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查询串，要求使用的内存不能超过1G。

**解答**：由上面第1题，可以看出，数据大则划为小的，如一亿个IP求Top
10，可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hashmap计数统计并按数量排序，最后归并或者最小堆依次处理每个小文件的top10以得到最后的结。

但如果数据规模比较小，能一次性装入内存呢?比如这第2题，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此可以考虑把他们都放进内存中去（300万个字符串假设没有重复，都是最大长度，那么最多占用内存3M\*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理），而现在只是需要一个合适的数据结构，在这里，HashMap绝对是最优先的选择。

所以这种情况下就可以放弃分而治之/hash映射的步骤**，直接上hash统计**，然后排序。So，针对此类典型的TOP
K问题，采取的对策往往是：hashmap + 堆。如下所示：

**hash_map统计：**先对这批海量数据预处理。具体方法是：维护一个Key为Query字串，Value为该Query出现次数的HashMap，即hash_map(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。

**堆排序：**第二步借助堆这个数据结构，找出Top
K，时间复杂度为N‘logK。即借助堆结构，我可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，最终的时间复杂度是：O（N）
+ N' \* O（logK），（N为1000万，N’为300万）。

当然，也可以采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。

**问题3：**海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。

如果每个数据元素只出现一次，而且只出现在某一台机器中，那么可以采取以下步骤统计出现次数TOP10的数据元素：

堆排序：在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆，比如求TOP10大，首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大）。

求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。

**但如果同一个元素重复出现在不同的电脑中呢，如下例子所述**：这个时候有两种方法：

**方法一：**遍历一遍所有数据，重新hash取摸，如此使得同一个元素只出现在单独的一台电脑中，然后采用上面所说的方法，统计每台电脑中各个元素的出现次数找出TOP10，继而组合100台电脑上的TOP10，找出最终的TOP10。

**方法二：**暴力求解。直接统计统计每台电脑中各个元素的出现次数，然后把同一个元素在不同机器中的出现次数相加，最终从所有数据中找出TOP10。

**问题4：**有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。

**方案1**：直接上hash映射：顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为a0,a1,..a9）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。

hash_map统计：找一台内存在2G左右的机器，依次对用hash_map(query,
query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。

堆/快速/归并排序：利用快速/堆/归并排序按照出现次数进行排序，将排序好的query和对应的query_cout输出到文件中，这样得到了10个排好序的文件（记为）。最后，对这10个文件进行归并排序（内排序与外排序相结合）。

**方案2**：一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。

**方案3：**与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。

**问题5：**给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，找出a、b文件共同的url？**可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。**

分而治之/hash映射：遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后只要求出1000对小文件中相同的url即可。

hash_set统计：求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

**问题6:**一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。

**方案1：**如果文件比较大，无法一次性读入内存，可以采用hash取模的方法，将大文件分解为多个小文件，对于单个小文件利用hash_map统计出每个小文件中10个最常出现的词，然后再进行归并处理，找出最终的10个最常出现的词。

方案2：通过hash取模将大文件分解为多个小文件后，除了可以用hash_map统计出每个小文件中10个最常出现的词，也可以用trie树统计每个词出现的次数，时间复杂度是O(n\*le)（le表示单词的平准长度），最终同样找出出现最频繁的前10个词（可用堆来实现），时间复杂度是O(n\*lg10)。

7.3 多层划分
------------

**多层划分其实本质上还是分而治之的思想，重在“分”的技巧上！**

适用范围：第k大，中位数，不重复或重复的数字

基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。

**问题1：**2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。

有点像鸽巢原理，整数个数为2\^32,也就是可以将这2\^32个数划分为2\^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。

**问题2:** 5亿个int找它们的中位数。

思路一：这个例子比上面那个更明显。首先将int划分为2\^16个区域，然后读取数据统计落到各个区域里的数的个数，之后根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。

实际上，如果不是int是int64，可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2\^24个区域，然后确定区域的第几大数，在将该区域分成2\^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2\^20，就可以直接利用direct
addr table进行统计了。

思路二：同样需要做两遍统计，如果数据存在硬盘上，就需要读取2次。方法同基数排序有些像，开一个大小为65536的int数组，第一遍读取，统计Int32的高16位的情况，也就是0-65535，都算作0,65536
- 131071都算作1。就相当于用该数除以65536。Int32 除以
65536的结果不会超过65536种情况，因此开一个长度为65536的数组计数就可以。每读取一个数，数组中对应的计数+1，考虑有负数的情况，需要将结果加32768后，记录在相应的数组内。

第一遍统计之后，遍历数组，逐个累加统计，看中位数处于哪个区间，比如处于区间k，那么0-
k-1的区间里数字的数量sum应该\<n/2（2.5亿）。而k+1 -
65535的计数和也\<n/2，第二遍统计同上面的方法类似，但这次只统计处于区间k的情况，也就是说(x
/ 65536) + 32768 = k。统计只统计低16位的情况。并且利用刚才统计的sum，比如sum =
2.49亿，那么现在就是要在低16位里面找100万个数(2.5亿-2.49亿)。这次计数之后，再统计一下，看中位数所处的区间，最后将高位和低位组合一下就是结果了。

7.4 Bloom filter
----------------

适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集

**问题1:**给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？

根据这个问题我们来计算下内存的占用，4G=2\^32大概是40亿\*8大概是340亿bit，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些url
ip是一一对应的，就可以转换成ip，则大大简单了。

7.5 Bitmap
----------

**问题1:**在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。

方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2\^32
\* 2 bit=1
GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。

方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。”

**问题2:**给40亿个不重复的unsigned
int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？

用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned
int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。

7.6 数据库/倒排索引
-------------------

**数据库索引**

适用范围：大数据量的增删改查

基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。

**倒排索引(Inverted index)**

适用范围：搜索引擎，关键字查询

基本原理及要点：一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。

7.7 分布式处理之Mapreduce
-------------------------

MapReduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。通俗来讲**，Mapreduce的原理就是一个归并排序。**

适用范围：数据量大，但是数据种类小可以放入内存

基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。

**问题1：**海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。

先对每台机器上的数进行大小为10的堆。之后采用归并排序的思想，将这N个机器上的数归并起来得到最终的TOP10。

**问题2：**一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N\^2个数的中数(median)？

先对每台机器上的数进行排序。排好序后采用归并排序的思想，将这N个机器上的数归并起来得到最终的排序。

**详细链接：https://blog.csdn.net/wuxiaosi808/article/details/78076936**

