
  * [redis的线程模型是什么？为什么单线程的redis效率要高得多？](#redis%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84redis%E6%95%88%E7%8E%87%E8%A6%81%E9%AB%98%E5%BE%97%E5%A4%9A)
  * [redis都有哪些数据类型？分别在哪些场景下使用比较合适？](#redis%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E5%88%AB%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E5%90%88%E9%80%82)
  * [redis的过期策略都有哪些？手写一下LRU代码实现？](#redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%8Blru%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
  * [如何保证Redis高并发、高可用？](#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81redis%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8)
  * [redis的持久化有哪几种方式？不同的持久化机制都有什么优缺点？](#redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9)
  * [redis集群模式的工作原理能说一下么？在集群模式下，redis的key是如何寻址的？分布式寻址都有哪些算法？了解一致性hash算法吗？如何动态增加和删除一个节点？](#redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B9%88%E5%9C%A8%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8Bredis%E7%9A%84key%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%BB%E5%9D%80%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%BB%E5%9D%80%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95%E5%90%97%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%A2%9E%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9)
  * [了解什么是redis的雪崩和穿透？redis崩溃之后会怎么样？系统该如何应对这种情况？如何处理redis的穿透？](#%E4%BA%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFredis%E7%9A%84%E9%9B%AA%E5%B4%A9%E5%92%8C%E7%A9%BF%E9%80%8Fredis%E5%B4%A9%E6%BA%83%E4%B9%8B%E5%90%8E%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%E7%B3%BB%E7%BB%9F%E8%AF%A5%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86redis%E7%9A%84%E7%A9%BF%E9%80%8F)
  * [如何保证缓存与数据库的双写一致性？](#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7)
  * [redis的并发竞争问题是什么？如何解决这个问题？了解Redis事务的CAS方案吗？](#redis%E7%9A%84%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3redis%E4%BA%8B%E5%8A%A1%E7%9A%84cas%E6%96%B9%E6%A1%88%E5%90%97)
  
  
  
### 面试题



#### redis的线程模型是什么？为什么单线程的redis效率要高得多？

redis是单线程模型

效率高的原因：单线程减少了线程间切换和锁的开销，基于内存实现，采用多路复用非阻塞IO实现

####  redis都有哪些数据类型？分别在哪些场景下使用比较合适？

（1）string:最基本的类型了，用来做简单的kv缓存

（2）hash：类似map的一种结构，这个一般就是可以将结构化的数据

比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在redis里，然后每次读写缓存的时候，可以就操作hash里的某个字段。

（3）list：有序列表

可以通过list存储一些列表型的数据结构，类似粉丝列表了、文章的评论列表

可以通过lrange命令，基于redis实现简单的高性能分页

（4）set：无序集合，自动去重

直接基于set将系统里需要去重的数据扔进去，自动就给去重了

可以基于set玩儿交集、并集、差集的操作，比如交集吧

（5）sorted set

排序的set，去重而且可以排序，

可以自定义排序，实现类似排行榜的功能

#### redis的过期策略都有哪些？手写一下LRU代码实现？

首先如果为Key设置了过期时间后，当其失效时，会进行被动删除和，定时删除，主动删除（当前已用内存超过maxmemory限定时，触发主动清理策略，可配置数据淘汰策略）。

如果内存空间占用过多，一般有六种种策略：

volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰；

volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰；

volatile-random：从已设置过期时间的数据集中任意选择数据淘汰 ；

allkeys-lru：从数据集中挑选最近最少使用的数据淘汰；

allkeys-random：从数据集中任意选择数据淘汰；

no-enviction（驱逐）：禁止驱逐数据。

LRU的实现可以通过继承LinkedHashMap并重写protected boolean
removeEldestEntry(Map.Entry eldest){}方法实现

#### 如何保证Redis高并发、高可用？

redis高并发：主从架构，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒10万的QPS。

redis高可用：如果你做主从架构部署，其实就是加上哨兵就可以了，就可以实现，任何一个实例宕机，自动会进行主备切换。

redis高并发的同时，还需要容纳大量的数据就需要redis集群，而且用redis集群之后，可以提供可能每秒几十万的读写并发。

#### redis的持久化有哪几种方式？不同的持久化机制都有什么优缺点？

redis的持久化是为了在重启后恢复数据

RDB是通过保存数据快照来实现的，优点是恢复速度快、占用带宽小，缺点是可能丢失数据

AOF是通过追加日志的形式来保存的，优缺点相反

#### redis集群模式的工作原理能说一下么？在集群模式下，redis的key是如何寻址的？分布式寻址都有哪些算法？了解一致性hash算法吗？如何动态增加和删除一个节点？

redis集群主要是为了突破单机redis在海量数据面前的内存瓶颈。

redis的集群架构支撑N个redis master node，每个master node都可以挂载多个slave node

采用读写分离的架构，对于每个master来说，写就写到master，然后读就从mater对应的slave去读

实现了高可用，因为每个master都有salve节点，那么如果mater挂掉，就会自动将某个slave切换成master

在redis集群架构下，每个redis要放开两个端口号，比如一个端口用来进行节点间通信的，进行故障检测，配置更新，故障转移授权;
另一个端口用来客户端通信。

#### 了解什么是redis的雪崩和穿透？redis崩溃之后会怎么样？系统该如何应对这种情况？如何处理redis的穿透？

redis的雪崩：同时有大量缓存失效或者缓存机器宕机，请求全部转发到DB，DB瞬时压力过重雪崩。

解决方法：服务限流或者降级，尽量设置随机的缓存时间，设置redis持久化，快速恢复数据方案吗

缓存穿透：是指查询一个一定不存在的数据

解决方法：布隆过滤器，或者对不存在的数据进行缓存（过期时间较短）

#### 如何保证缓存与数据库的双写一致性？

Cache Aside Pattern

（1）读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应

（2）更新的时候，先删除缓存，然后再更新数据库（再次删除）

#### redis的并发竞争问题是什么？如何解决这个问题？了解Redis事务的CAS方案吗？

redis的并发竞争问题是多客户端同时并发写一个 key，解决方法：分布式锁，加时间戳

redis事务的CAS方案（乐观锁）工作机制：

watch指令在redis事务中提供了类似于CAS的行为。为了检测被watch的keys在是否有多个clients同时改变引起冲突，这些keys将会被监控。如果至少有一个被监控的key在执行exec命令前被修改，整个事物将会回滚，不执行任何动作，从而保证原子性操作，并且执行exec会得到null的回复。注意watch的key是对整个连接有效的，事务也一样。如果连接断开，监视和事务都会被自动清除。
