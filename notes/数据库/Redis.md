* [Redis常用的数据类型](#redis%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)
* [发布与订阅](#%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85)
* [持久化机制](#%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6)
* [Redis使用场景](#redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF)
* [面试题](#%E9%9D%A2%E8%AF%95%E9%A2%98)
  * [redis的线程模型是什么？为什么单线程的redis效率要高得多？](#redis%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84redis%E6%95%88%E7%8E%87%E8%A6%81%E9%AB%98%E5%BE%97%E5%A4%9A)
  * [redis都有哪些数据类型？分别在哪些场景下使用比较合适？](#redis%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E5%88%AB%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E5%90%88%E9%80%82)
  * [redis的过期策略都有哪些？手写一下LRU代码实现？](#redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%8Blru%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
  * [如何保证Redis高并发、高可用？](#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81redis%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8)
  * [redis的持久化有哪几种方式？不同的持久化机制都有什么优缺点？](#redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9)
  * [redis集群模式的工作原理能说一下么？在集群模式下，redis的key是如何寻址的？分布式寻址都有哪些算法？了解一致性hash算法吗？如何动态增加和删除一个节点？](#redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B9%88%E5%9C%A8%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8Bredis%E7%9A%84key%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%BB%E5%9D%80%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%BB%E5%9D%80%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95%E5%90%97%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%A2%9E%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9)
  * [了解什么是redis的雪崩和穿透？redis崩溃之后会怎么样？系统该如何应对这种情况？如何处理redis的穿透？](#%E4%BA%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFredis%E7%9A%84%E9%9B%AA%E5%B4%A9%E5%92%8C%E7%A9%BF%E9%80%8Fredis%E5%B4%A9%E6%BA%83%E4%B9%8B%E5%90%8E%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%E7%B3%BB%E7%BB%9F%E8%AF%A5%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86redis%E7%9A%84%E7%A9%BF%E9%80%8F)
  * [如何保证缓存与数据库的双写一致性？](#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7)
  * [redis的并发竞争问题是什么？如何解决这个问题？了解Redis事务的CAS方案吗？](#redis%E7%9A%84%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3redis%E4%BA%8B%E5%8A%A1%E7%9A%84cas%E6%96%B9%E6%A1%88%E5%90%97)


Redis是一种支持Key-Value等多种数据结构的存储系统(NoSQL)。可用于缓存，事件发布或订阅，高速队列等场景。该数据库使用ANSI
C语言编写，支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。

Redis不支持事务，但是通过提供了打包执行的功能，即这个包里面的所有命令必须要一起执行，此外还可以锁定某个Key，在打包执行命令时如果检测到这个Key发生了变化，则直接回滚。

Redis使用单线程的IO复用模型。

### Redis常用的数据类型

Redis一共支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）和zset（sorted
set有序集合）。

1、String：Strings就是一个最最简单的Key-Value形式存储的变量。其中Value既可以是数字也可以是字符串。其实现方式是在Redis内部默认存储一个字符串，被redisObject引用，当检测到数字操作如自增自减incr、decr等等命令时，自动转化为数字进行计算，计算完毕后再转化为String存储起来。

2、Hash:Hash存储是键值对的value。即Key-Hash，而Hash又是一个k-v的结构，如果使用的Memcached，则需要把整个Hash打包存储在内存中，如果需要查询其中某个值，还要全部取出整个Hash，再查找对应值。而Redis可以直接通过命令获取到Value，大大提高了性能。
其实现原理：当成员较少时，Redis为了节约内存会采用类似一维数组的紧凑存储，而当对象较多时，则直接转为HashMap存储。

> Redis的哈希表使用链地址法（separate
chaining）来解决键冲突：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。（每次都是在头部插入）

3、Set：Set是一个无序的天然去重的集合，即Key-Set。此外还提供了交集、并集等一系列直接操作集合的方法，对于求共同好友、共同关注什么的功能实现特别方便。其底层是靠HashMap实现的，其中value为null；

4、List：List是一个有序可重复的集合，其遵循FIFO的原则，底层是依赖双向链表实现的，因此支持正向、反向双重查找。通过List，我们可以很方面的获得类似于最新回复这类的功能实现。

5、SortedSet：类似于java中的TreeSet，是Set的可排序版。此外还支持优先级排序，维护了一个score的参数来实现。其底层主要依赖HashMap来实现的，通过维持插入的数值和Score优先级的映射来进行排序。

### 发布与订阅

>   Redis的发布与订阅（发布/订阅）是它的一种消息通信模式，一方发送信息，一方接收信息。下图是三个客户端同时订阅同一个频道。

![https://img-blog.csdnimg.cn/20181224163405400](media/9fc4ef4042e6927fb20e0b60a9281740.png)

下图是有新信息发送给频道1时，就会将消息发送给订阅它的三个客户端：

![https://img-blog.csdnimg.cn/20181224163405417](media/de254d956041a06f12d467c39dbc77e1.png)

### 持久化机制

两种持久化机制是RDB和AOF机制。

**RDB持久化是**指用数据集快照的方式记录redis数据库的所有键值对。

两个命令：SAVE命令会阻塞主进程来完成写文件，BGSAVE命令会创建子进程来完成写文件，主进程会继续处理命令。

**优点**：

1.只有一个文件dump.rdb，方便持久化。

2.容灾性好，一个文件可以保存到安全的磁盘。

3.性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。

4.相对于数据集大时，比AOF的启动效率更高。

**缺点：**

1.数据安全性低，通过配置save参数来达到定时的写快照，比如 每900
秒有1个键被修改就进行一次快照，每600秒至少有10个键被修改进行快照，每30秒有至少10000个键被修改进行记录。所以如果当服务器还在等待写快照时出现了宕机，那么将会丢失数据。

2.fork子进程时可能导致服务器停机1秒，数据集太大。

**AOF持久化**是指所有的命令行记录以redis命令请求协议的格式保存为aof文件。

**优点：**

1.数据安全，aof持久化可以配置appendfsync属性，有always，每进行一次命令操作就记录到aof文件中一次；everySec，就是每秒内进行一次文件的写操作；no就是不进行aof文件的写操作。

2.通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。

3.AOF机制的rewrite模式，用来将过大的aof文件缩小，实现原理是将所有的set通过一句set命令总结，所有的SADD命令用总结为一句，这样每种命令都概括为一句来执行，就可以减少aof文件的大小了。（注意，在重写的过程中，是创建子进程来完成重写操作，主进程每个命令都会在AOF缓冲区和AOF重写缓冲区进行保存，这样旧版aof文件可以实现数据最新，当更新完后将重写缓冲区中的数据写入新的aof文件中然后就可以将新的文件替换掉旧版的文件）。

**缺点：**

1.文件会比RDB形式的文件大。

2.数据集大的时候，比rdb启动效率低。


主从复制：《[Redis设计与实现》](https://www.cnblogs.com/lukexwang/p/4711977.html)



###  Redis使用场景

Redis使用内存提供存储，通过持久化功能保存数据。且针对request是单线程操作。https://blog.csdn.net/hguisu/article/details/8836819

1、查找最新的回复。

如果在传统的关系型数据库，这就需要使用select \* from table where name="" order
by time desc limit
100；这十分消耗数据库性能，但是通过Redis，就可以直接在Redis里面通过Id创建一个List，指定长度1w，当需要查找时，直接输出该list的后100条记录。

2、排行问题

常见的排行问题，例如最热话题、游戏排名等等，这些都可以通过Redis来轻松实现，直接使用ZRank即可得到。

3、删除过期数据

Redis不是真正意义上的可持久化数据库，可以给数据加上一个有效时间，在有效时间超过时，Redis会自动删除对应数据。

**更多应用场景：https://blog.csdn.net/hguisu/article/details/8836819**

其他：*Redis实现摇一摇与附近的人功能*

### 面试题



#### redis的线程模型是什么？为什么单线程的redis效率要高得多？

redis是单线程模型

效率高的原因：单线程减少了线程间切换和锁的开销，基于内存实现，采用多路复用非阻塞IO实现

####  redis都有哪些数据类型？分别在哪些场景下使用比较合适？

（1）string:最基本的类型了，用来做简单的kv缓存

（2）hash：类似map的一种结构，这个一般就是可以将结构化的数据

比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在redis里，然后每次读写缓存的时候，可以就操作hash里的某个字段。

（3）list：有序列表

可以通过list存储一些列表型的数据结构，类似粉丝列表了、文章的评论列表

可以通过lrange命令，基于redis实现简单的高性能分页

（4）set：无序集合，自动去重

直接基于set将系统里需要去重的数据扔进去，自动就给去重了

可以基于set玩儿交集、并集、差集的操作，比如交集吧

（5）sorted set

排序的set，去重而且可以排序，

可以自定义排序，实现类似排行榜的功能

#### redis的过期策略都有哪些？手写一下LRU代码实现？

首先如果为Key设置了过期时间后，当其失效时，会进行被动删除和，定时删除，主动删除（当前已用内存超过maxmemory限定时，触发主动清理策略，可配置数据淘汰策略）。

如果内存空间占用过多，一般有六种种策略：

volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰；

volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰；

volatile-random：从已设置过期时间的数据集中任意选择数据淘汰 ；

allkeys-lru：从数据集中挑选最近最少使用的数据淘汰；

allkeys-random：从数据集中任意选择数据淘汰；

no-enviction（驱逐）：禁止驱逐数据。

LRU的实现可以通过继承LinkedHashMap并重写protected boolean
removeEldestEntry(Map.Entry eldest){}方法实现

#### 如何保证Redis高并发、高可用？

redis高并发：主从架构，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒10万的QPS。

redis高可用：如果你做主从架构部署，其实就是加上哨兵就可以了，就可以实现，任何一个实例宕机，自动会进行主备切换。

redis高并发的同时，还需要容纳大量的数据就需要redis集群，而且用redis集群之后，可以提供可能每秒几十万的读写并发。

#### redis的持久化有哪几种方式？不同的持久化机制都有什么优缺点？

redis的持久化是为了在重启后恢复数据

RDB是通过保存数据快照来实现的，优点是恢复速度快、占用带宽小，缺点是可能丢失数据

AOF是通过追加日志的形式来保存的，优缺点相反

#### redis集群模式的工作原理能说一下么？在集群模式下，redis的key是如何寻址的？分布式寻址都有哪些算法？了解一致性hash算法吗？如何动态增加和删除一个节点？

redis集群主要是为了突破单机redis在海量数据面前的内存瓶颈。

redis的集群架构支撑N个redis master node，每个master node都可以挂载多个slave node

采用读写分离的架构，对于每个master来说，写就写到master，然后读就从mater对应的slave去读

实现了高可用，因为每个master都有salve节点，那么如果mater挂掉，就会自动将某个slave切换成master

在redis集群架构下，每个redis要放开两个端口号，比如一个端口用来进行节点间通信的，进行故障检测，配置更新，故障转移授权;
另一个端口用来客户端通信。

#### 了解什么是redis的雪崩和穿透？redis崩溃之后会怎么样？系统该如何应对这种情况？如何处理redis的穿透？

redis的雪崩：同时有大量缓存失效或者缓存机器宕机，请求全部转发到DB，DB瞬时压力过重雪崩。

解决方法：服务限流或者降级，尽量设置随机的缓存时间，设置redis持久化，快速恢复数据方案吗

缓存穿透：是指查询一个一定不存在的数据

解决方法：布隆过滤器，或者对不存在的数据进行缓存（过期时间较短）

#### 如何保证缓存与数据库的双写一致性？

Cache Aside Pattern

（1）读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应

（2）更新的时候，先删除缓存，然后再更新数据库（再次删除）

#### redis的并发竞争问题是什么？如何解决这个问题？了解Redis事务的CAS方案吗？

redis的并发竞争问题是多客户端同时并发写一个 key，解决方法：分布式锁，加时间戳

redis事务的CAS方案（乐观锁）工作机制：

watch指令在redis事务中提供了类似于CAS的行为。为了检测被watch的keys在是否有多个clients同时改变引起冲突，这些keys将会被监控。如果至少有一个被监控的key在执行exec命令前被修改，整个事物将会回滚，不执行任何动作，从而保证原子性操作，并且执行exec会得到null的回复。注意watch的key是对整个连接有效的，事务也一样。如果连接断开，监视和事务都会被自动清除。
