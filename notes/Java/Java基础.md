一．Java基础
============

1.1 Java的数据类型
------------------

### 1.1.1 8种基本数据类型

布尔型: boolean

字符型: char

整数型: byte, short, int, long

浮点数型: float, double

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//0dbe16b4678f239f46835744712d3d4d.png)

### 1.1.2 装箱和拆箱

自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。

原始类型: boolean，char，byte，short，int，long，float，double

封装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double

### 1.1.3 String转为int型，判断能不能转？如何转？

答：可以转（Integer.parseInt(s)），但是可能会出现NumberFormatException异常，原因可能有以下几点：

-   输入的字符串中含有字母。

-   输入为空。

-   输入超出int上限时，这个时候可以考虑用Long.parseLong(s)转换为long。

### 1.1.4 short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 +=1;有什么错?

>   1). 对于short
>   s1=1;s1=s1+1来说，在s1+1运算时会自动提升表达式的类型为int，那么将int赋予给short类型的变量s1会出现类型转换错误。

>   2). 对于short s1=1;s1+=1来说
>   +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。

### 1.1.5 int与Integer区别

1、Integer是int的包装类，int则是java的一种基本数据类型。  
2、Integer变量必须实例化后才能使用，而int变量不需要。

3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值。  
4、Integer的默认值是null，int的默认值是0。

**更深入的理解**

1.  由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远不相等（通过new生成的两个对象的内存地址并不相同）。

2.  Integer变量和int变量比较时，只要两个两个变量的值是相等的，则返回true（包装类和基本数据类比较时，会自动拆箱）。

3.  非new生成的Integer变量和new
    Integer()生成的变量比较时，结果为false（因为非new生成的Integer变量指向的是java常量池中的对象，而new
    Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）。

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//b35d5e10d53c2b23b0f2dfe9f1444db9.png)

1.  对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false。

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//ffd60100cc9ec16c9276ab2609f0caa3.png)

**原因如下**：Java在编译Integer i = 100时，会翻译成为Integer i =
Integer.valueOf(100)；，而Java
API中对Integer类型的valueOf的定义如下，从中可以看出，Java对于-128到127之间的数，会进行缓存。

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//a2ba24222e8933474d99ae95496d0efc.png)

### 1.1.6 字符区别

字节是存储容量的基本单位，字符是数字，字母，汉字以及其他语言的各种符号。

1字节=8个二进制单位。

一个字符由一个字节或多个字节的二进制单位组成。

### 1.1.7 Java基本类型与引用类型的区别

基本类型保存原始值，引用类型保存的是引用值（引用值就是指对象在堆中所处的位置/地址）。

### 1.1.8 静态变量和全局变量的区别

**局部变量：**在方法内定义的变量称为“局部变量”或“临时变量”，方法结束后局部变量占用的内存将被释放。

**全局变量：**全局变量，又称“外部变量”，它不是属于哪个方法，作用域从定义的地址开始到源文件结束。当局部变量与全局变量重名时，起作用的是局部变量。Java中没有全局变量的定义。

**成员变量：**在类体的变量部分中定义的变量，也称为字段。

非静态成员变量，又称为属性，对该类不同的对象来说，属性是不同的。

静态成员变量，一个类中只有一个该变量，该类不同的对象共享同一个静态成员变量

局部变量，是方法内部定义的变量，只在方法内部可见，在该方法结束后，由垃圾回收器自动回收。

1.2 Java的基本特征
------------------

### 1.2.1 Java的四个基本特征

**抽象：**抽象是将一类的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两个方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

**继承：**继承是从已有类得到的继承信息创建新类的过程。提供继承信息放入类被成为父类，得到继承信息的类被称为子类。Java的继承通过extends关键字来实现单继承，接口可以实现多继承。

**封装：**把对象的属性和行为（方法）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。在Java中，对于对象的内部属性一般用private来实现隐藏，并通过set和get方法对外提供访问接口。

**多态：**不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态。多态存在的三个必要条件：要有继承、要有重写、父类引用指向子类对象。

### 1.2.2 方法重写和方法重载

**重写**是由于继承关系中的子类有一个和父类同名同参数的方法，会覆盖掉父类的方法。

**重载**是因为一个同名方法可以传入多个参数组合。同名方法如果参数相同，即使返回值不同也是不能同时存在的，编译会出错。两者都是Java中多态性一个的一个体现，方法重写是父类与子类之间多态性的体现，而方法重载主要是类内部多态性的一个体现。

从JVM实现的角度来看，**重写又叫运行时多态**，编译时看不出子类调用的是哪个方法，但是运行时操作数栈会先根据子类的引用去子类的类信息中查找方法，找不到的话再到父类的类信息中查找方法。而**重载则是编译时多态**，因为编译期就可以确定传入的参数组合，决

定调用的具体方法是哪一个了。

**Java中static方法不能被**重写，因为方法重写是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。

Java中也不可以重写private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。

### 1.2.3 Java创建对象的四种方法

1.  使用new关键字。

2.  使用Class类的newInstance方法（反射）。

3.  使用clone方法。

4.  反序列化。

### 1.2.4 值传递与引用传递

**值传递（pass by
value）**是指在**调用函数时将实际参数复**制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。

**引用传递（pass by
reference）**是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

**Java中只有是值传递的，对于基本类型来说，传递的就是值。对于一个具体的对象来说，值的内容是对象的引用，**这样在函数中改变这个地址的值（例如重新new一个对象）实际上不会影响到原对象，但是如果修改这个地址指向的内容，就会对原对象产生影响。

[详细解释](https://www.cnblogs.com/wchxj/p/8729503.html)

### 1.2.5 C++/JAVA/C的区别

C语言是面向过程的语言，Java与C++都是面向对象的语言，都使用了面向对象的思想（封装、继承、多态），由于面向对象由许多非常好的特性（继承、组合等），因此二者有很好的可重用性。

**主要不同点：**

1、Java为解释性语言，其运行过程为：程序源代码经过Java编译器编译成字节码，然后由JVM解释执行。而C/C++为编译型语言，源代码经过编译和链接后生成可执行的二进制代码，可直接执行。因此Java的执行速度比C/C++慢，但Java能够跨平台执行，C/C++不能。

2、Java是纯面向对象语言，所有代码（包括函数、变量）必须在类中实现，除基本数据类型（包括int、float等）外，所有类型都是类。此外，Java语言中不存在全局变量或者全局函数，而C++可以定义全局变量和全局函数。

3、在Java中不可能直接操作对象本身，所有的对象都由一个引用指向，必须通过这个引用才能访问对象本身，包括获取成员变量的值，改变对象的成员变量，调用对象的方法等。而在C++中存在引用，对象和指针三个东西，这三个东西都可以访问对象。

4、与C++语言相比，Java语言不支持多重继承，但是Java语言引入了接口的概念，可以同时实现多个接口。由于接口也有多态特性，因此Java语言中可以通过实现多个接口来实现与C++语言中多重继承类似的目的。

5、在C++语言中，需要开发人员去管理内存的分配（包括申请和释放），而Java语言提供了垃圾回收器来实现垃圾的自动回收，不需要程序显示地管理内存的分配。

6、C++有goto，Java没有goto。但是Java提供了一种类似的跳转机制：标签。用法
label：。（break label ，continue label）

1.3 String类相关
----------------

### 1.3.1 String类为什么是不可变的

首先看下JDK中String类的定义：

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//e0e613e42744573c939f118194312d9d.png)

从中可以看出：
String类被final关键字修饰，所以不能被继承。其次String类的底层是一个私有的被final修饰的char型数组，这个数组指向的堆地址不能被修改。（理论上char数组里的值是可以改变的，但是String并没有提供修改的方法，但是但是**实际上这个私有的char型数组的值也是可以通过反射进行修改的**）。

String提供的一些方法如substring， replace， replaceAll，
toLowerCase等，这些方法的返回都是一个新的String对象(修改的过

程中复制了一份新的char数组)。

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//32bd5ef53a41a4565747f92e446988e7.png)

### 1.3.2 String字符串的创建方式

**String str = “hello”;**

这种方法创建字符串
对象的时候，JVM首先会检查字符串常量池中是否存在该字符串的对象，如果已经存在，那么就不会在字符串常量池中再创建了，直接返回该字符串常量池内存中的内存地址。如果该字符串还不存在字符串常量池中，那么就会在字符串常量池中先创建该字符串的对象，然后在返回其内存地址。

**String str = new String(“hello”);**

这种方式创建字符串对象的时候
，JVM首先会检查字符串常量池中是否存在“hello”的字符串，如果已经存在，则不会在字符串常量池中创建了，如果还没有存在，那么就会在字符串常量池中创建“hello”字符串对象。然后还会去堆内存中再创建一份字符串的对象（凡是以new关键字创建的对象，JVM都会在堆内存中开辟一个新的空间，创建一个新的对象），把字符串常量池中的“hello”字符串内容拷贝至内存中的字符串对象，然后返回堆内存中字符串对象的内存地址。

### 1.3.3 String的intern方法

String的intern方法：用来返回常量池中的某字符串，如果常量池中已经存在该字符

串，则直接返回常量池中该对象的引用。否则，在常量池中加入该对象，然后返回引用。在jdk1.7之前，字符串常量存储在方法区的PermGen
Space。在jdk1.7之后，字符串常量重新被移到了堆中，且如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。

如果在程序中用 +
号来连接字符串，实际上都是通过StringBuilder来实现的，所以如果大量用到+号，可能会导致效率较低。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。

### 1.3.4 为什么重写equals方法，就必须重写hashcode方法

答：equals和hashcode都来自于Object类，Object类中的equals方法比较两个引用类型的对象时，只有两个对象的地址相同时，才返回true。hashCode()返回的是对象的哈希码值。这个哈希码的作用是确定该对象在哈希表中的索引位置。String类重写了equals方法和hashcode方法。

首先equals与hashcode间的关系是这样的：

1、如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同。

2、如果两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false)。

由于为了提高程序的效率才实现了hashcode方法，先进行hashcode的比较，如果不同，那没就不必在进行equals的比较了，这样就大大减少了equals比较的次数，这对比需要比较的数量很大的效率提高是很明显的，一个很好的例子就是在集合中的使用。

所以为什么必须要重写hashcode方法，其实简单的说就是为了保证同一个对象，保证在equals相同的情况下hashcode值必定相同，如果重写了equals而未重写hashcode方法，可能就会出现两个没有关系的对象equals相同的（因为equal都是根据对象的特征进行重写的），但hashcode确实不相同的。

### 1.3.5 构造相同hash的字符串进行攻击，这种情况应该怎么处理

**攻击原理：**

当客户端发送一个请求到服务器，如果该请求中带有参数，服务器端会将参数名-参数值作为key-value保存在HashMap中。如果有人恶意构造请求，在请求中加入大量相同hash值的String参数名（key），那么在服务器端用于存储这些key-value对的HashMap会被强行退化成链表，如图：

![Hash Mapè¢«æ»å»ååå¯¹æ¯](https://raw.githubusercontent.com/LLLRS/git_resource/master//16897aeb5c6e7b6cc3664bb7fcf2db54.png)

如果数据量足够大，那么在查找，插入时会占用大量CPU，达到拒绝服务攻击的目的。

**怎么处理：**

限制POST和GET请求的参数个数

限制POST请求的请求体大小

Web Application FireWall（WAF）

**JDK7如何处理**：

HashMap会动态的使用一个专门TreeMap实现来替换掉它。

### 1.3.6 String、StringBuilder、StringBuffer的比较

String 是不可变的，StringBuffer、StringBuilder是可变的。

String 、StringBuffer是线程安全的，StringBuilder是线程不安全的
（StringBuffer的append操作用了synchronized）。

String对象串联的效率最慢，单线程下字符串的串联用StringBuilder，多线程下字符串的串联用StrngBuffer。

StringBuilder、StringBuffer 的方法都会调用AbstractStringBuilder
中的公共方法，如super.append(...)。只是StringBuffer 会在方法上加synchronized
关键字，进行同步。最后，如果程序不是多线程的，那么使用StringBuilder
效率高于StringBuffer。

1.4 Java的反射机制
------------------

JAVA反射机制是**在运行状态中**，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。这种**动态获取信息以及动态调用对象方法的功能**称为java语言的反射机制。

通过反射可以访问一个对象的私有的属性和方法。反射通常用在注解、Spring配置文件、动态代理中。

反射的底层主要是通过Class类来实现的。

1.5 Java关键字
--------------

### 1.5.1 修饰符

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//711139ea7d797a9c33e7d6ca688ad9a5.png)

不写时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。

不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。

### 1.5.2 final关键字

**final关键字主要用在三个地方：变量、方法、类。**

**变量：**对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

**方法：**使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。

**类：**当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。

### 1.5.3 static关键字

static关键字主要用在三个地方:

**修饰成员变量和成员方法：**被 static修饰的成员变量和成员方法属于类，不属于单个

这个类的某个对象，被类中所有对象共享，可以通过类名调用。

**修饰代码块：**静态代码块定义在类中方法外,
静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。
该类不管创建多少对象，静态代码块只执行一次。

**修饰类（只能用于内部类）：**静态内部类没有外部类引用，不能使用任何外部类的非static成员变量和方法。静态内部类延迟加载，只有用到的时候才会被创建，且只会被创建一次。

**静态方法与非静态方法**

静态方法属于类，非静态方法属于对象。静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法，非静态方法则无此限制。

**静态代码块与非静态代码块**

相同点：
都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。

不同点：
静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new自动执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。

非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化。

this关键字用于引用类的当前实例。

super关键字用于从子类访问父类的变量和方法。

static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。

1.6 Java的IO
------------

### 1.6.1 Java的IO模型

一个IO操作其实分成了两个步骤：**发起IO请求（**查看数据是否就绪**）和实际的IO操作（**内核将数据拷贝到用户线程**）。**

阻塞IO和非阻塞IO的区别在于第一步，发起的IO请求是否会被阻塞，如果数据没有就绪，用户线程一直等待数据就绪，那么就是阻塞IO，如果不阻塞，那么就是非阻塞IO。

同步IO和异步IO是针对用户线程和内核的交互来说，也就是第二个步骤是否阻塞。**对于同步IO：**当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程。**而异步IO：**只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。**同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持**。

**Unix 下共有五种IO模型：**阻塞IO、非阻塞IO、多路复用IO、信号驱动IO和异步IO。

**阻塞IO模型**：最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。

**非阻塞IO模型：**当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。

**多路复用IO模型：**多路复用IO模型是目前使用得比较多的模型。Java
NIO实际上就是多路复用IO。在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。

**信号驱动IO模型：**在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。

**异步IO模型：**异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous
read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。这也就说在异步IO模型中，**IO操作的两个阶段都不会阻塞用户线程**，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。**用户线程中不需要再次调用IO函数进行具体的读写**。

这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用IO函数进行实际的读写操作。

前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。*详细看这篇文章*

上面所述Unix中的五种IO模型，除信号驱动IO外，Java对其它四种IO模型都有所支持。其中Java最早提供的Blocking
IO即是阻塞I/O（JDK1.4以前），而NIO（JDK1.4）即是非阻塞IO，同时通过NIO实现的Reactor模式即是IO复用模型的实现，通过AIO（JDK1.7）实现的Proactor模式即是异步IO模型的实现。

### 1.6.2 Java NIO的原理

**Java NIO由Channel、Buffer和Selector三部分组成**。

**Channel：**类似于传统IO中的Stream（InputStream），但是Channel是双向，既可用来进行读操作，又可用来进行写操作。（FileChannel、SocketChannel）

**Buffer**：缓冲区，是一个连续数组。Channel提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由Buffer。（ByteBuffer、IntBuffer）。Buffer的三个参数：capacity、position和limit。capacity代表了Buffer的容量。position在当前读/写的位置。limit表示还可以读或者写数据的大小。

**Selector：**NIO的核心类。Selector能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，**只是用一个单线程就可以管理多个通道，也就是管理多个连接。**这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//986d9753507cbad4a63f11702c25229d.png)

### 1.6.3 客户端连接服务器的IO模式

**服务器单线程逐个处理所有请求：**使用阻塞I/O的服务器，一般使用循环，逐个接受连接请求并读取数据，然后处理下一个请求。存在问题：单线程逐个处理所有请求，同一时间只能处理一个请求，等待I/O的过程浪费大量CPU资源，同时无法充分使用多CPU的优势。

**服务器为每个请求创建一个线程：**一个连接建立成功后，创建一个单独的线程处理其I/O操作，即使用多线程来支持多个客户端来访问服务器。存在问题：每次接收到新的连接

都要新建一个线程，处理完成后销毁线程，代价大。当有大量地短连接出现时，性能比较低。

**服务器使用线程池处理请求**：针对上面多线程的模型中，出现的线程重复创建、销毁带来的开销，可以采用线程池来优化。每次接收到新连接后从池中取一个空闲线程进行处理，处理完成后再放回池中，重用线程避免了频率地创建和销毁线程带来的开销。存在问题：在大量短连接的场景中性能会有提升，因为不用每次都创建和销毁线程，而是重用连接池中的线程。但在大量长连接的场景中，因为线程被连接长期占用，不需要频繁地创建和销毁线程，因而没有什么优势。

**服务器使用非阻塞IO（NIO）处理请求**：上述两种模型都存在一个共同的问题：读和写操作都是同步阻塞的，面对大并发（持续大量连接同时请求）的场景，需要消耗大量的线程来维持连接。CPU在大量的线程之间频繁切换，性能损耗很大。一旦单机的连接超过1万，甚至达到几万的时候，服务器的性能会急剧下降。

而NIO的Selector却很好地解决了这个问题，用主线程（一个线程或者是CPU个数的线程）保持住所有的连接，管理和读取客户端连接的数据，将读取的数据交给后面的线程池处理，线程池处理完业务逻辑后，将结果交给主线程发送响应给客户端，少量的线程就可以处理大量连接的请求。

### 1.6.4 Java IO用到的设计模式

在Java IO库的设计中，使用了两个结构模式**：装饰模式和适配器模式**。

**装饰模式：**赋予被装饰的类更多的功能。

典型的装饰器模式的类结构图如下：

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//3125e79fdedae4a13f2444aac3d7e68f.png)

**Component:** 抽象组件角色，
定义一组抽象的接口，规定这个被装饰组件都有哪些功能。

**ConcreteComponent:** 实现这个抽象组件的所有功能。

**Decorator:**
装饰器角色，它持有一个Component对象实例的引用，定义一个与抽象组件一致的接口。

**ConcreteDecorator:** 具体的装饰器实现者，负责实现装饰器角色定义的功能。

如下图所示是InputStream及其子类的结构图：

![https://user-gold-cdn.xitu.io/2018/1/28/1613bb200d56aade?imageslim](https://raw.githubusercontent.com/LLLRS/git_resource/master//bdfb8ef001830735af6efd68c8d6cbd0.png)

InputStream的子类实现了其中定义的各种抽象方法，由图可以清楚的看出其子类大概分为两个层次。第一层为图中的蓝色框图所示，FileInputStream、FilterInputStream、ByteArrayInputStream等，她们主要定义了流式数据的获取来源，比如FileInputStream表示一个能从文件读取字节的InputStream类，ByteArrayInputStream表示能从字节数组中读取字节的InputStream类。其中比较独特的是FilterInputStream，FilterInputStream创建时需要传入一个InputStream类型的对象，FilterInputStream中几乎所有方法都是调用传入的InputStream对象的对应方法。所以FilterInputStream只是透明地提供扩展功能的输入流的包装。

**以BufferedInputStream、FileInputStream来演示Java
IO中的装饰模式，其类图可以作为：**

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//ffc6609efc88ad421c40dc3ea93cb3c6.png)

**FileInputStream fis = new FileInputStream("/test.txt");**

**BufferedInputStream bis = new BufferedInputStream(fis);**

使用装饰模式，就相当于一个动态的继承，可以手动的在代码中将不同的功能组合在一起，比如只需将功能1的实例传入功能2的实例中，使得功能2实例获取到功能1，这种动态的组合方式将会使代码更加简洁、高效、利于维护管理。

**适配器模式：将**一个接口适配到另一个接口，如将字符串数据转变成字节数据保存到文件中，将字节数据转变成流数据等。

>   在Java IO
>   中主要分为字节流、字符流，但是要用一个InputStream字节流对象去读取文件中的Unicode数据，可以使用InputStreamReader，其源码简化为：

**BufferedReader br = new BufferedReader(new InputStreamReader(new
FileInputStream("test.txt")));**

其中InputStream类是被适配者，InputStreamReader
是她的适配器。通过适配器模式我们就可以通过字节流对象去读取字符了。

**装饰模式和适配器模式**的区别：

装饰模式是保持原有对象的接口，但是增强原对象的功能，或者原有对象的处理方式来提升性能。适配器模式是将一个接口转换为另外一个接口，通过改变接口来达到重复使用的目的。

### 1.6.5 字节流与字符流

Java的流式输入、输出是建立在四个抽象类的基础上的：InputStream、OutputStream、Reader、Writer。其中InputStream、OutputStream负责处理字节类型数据，Reader、Writer负责字符型数据。

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//1f4097e5d8de20d42f0608237fa21115.png)

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//5975eff8ac2bf4c5b88531ca9b8276a9.png)

InputStreamReader
类是从字节流到字符流的桥梁：它读入字节，并根据指定的编码方式，将之转换为字符流。

**字节流与字符流的区别**

1、字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的

2、字节流与字符流主要的区别是他们的的处理方式。字节流：处理字节和字节数组或二进制对象。字符流：处理字符、字符数组或字符串。

1.7 Object类详解
----------------

Object类是类层次结构的根类。每个类都使用Object作为超类。所有对象（包括数组）都实现这个类的方法。

### 1.7.1 clone方法

**protected** native Object **clone**() throws CloneNotSupportedException

Object类的clone方法执行特定的复制操作。首先，如果此对象的类不能实现接口

Cloneable（标识），则会抛出
CloneNotSupportedException（所有的数组都被视为实现接口
Cloneable）。Object类本身不实现接口Cloneable，所以在类为Object的对象上调用 clone
方法将会导致在运行时抛出异常。

此方法会创建此对象的类的一个**新实例**，新的对象为原对象的浅克隆**（shadow
clone）**，也就是基本数据类型复制的是对应的值，引用类型复制的是对应的地址。但是**深克隆（deep
clone）中每一个引用类型也是一个新的对象。**

**如何实现深克隆**：引用链上的每一级对象都要被显式的拷贝（实现接口Cloneable）。所以创建彻底的深拷贝是非常麻烦的，尤其是在引用关系非常复杂的情况下，或者在引用链的某一级上引用了一个第三方的对象，而这个对象没有实现clone方法，那么在它之后的所有引用的对象都是被共享的。

**new操作符和clone方法的区别**

new操作符的本意是分配内存。程序执行到new操作符时，首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。

而clone在第一步是和new相似的，都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。

### 1.7.2 getClass方法

**public** native **final**
[Class](mk:@MSITStore:F:\FeigeDownload\学习资料\java书籍\JDK_API_1_6_zh_CN.CHM::/java/lang/Class.html)**\<?\>
getClass()**

此方法返回此对象的运行时类对象。Class类没有公共构造方法，Class对象是在加载类时由Java虚拟机以及通过调用类加载器中的defineClass方法自动构造的。

**"类对象"的概念：**在Java中，类是是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称之为"类对象"。

**Object类和Class类没有直接的关系。**Object类是一切Java类的父类，对于普通的Java类，即便不声明，也是默认继承了Object类。Class类是用于Java反射机制的，一切Java类，都有一个对应的Class对象。Class类的实例表示，正在运行的Java应用程序中的类和接口。

知乎上有这样一个问题：

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//0fecba1fe54d531651ddfef219c15d7e.png)

**解释如下：**

这个问题中，第1个假设是错的：java.lang.Object是一个Java类，但并不是java.lang.Class的一个实例。后者只是一个用于描述Java类与接口的、用于支持反射操作的类型。这点上Java跟其它一些更纯粹的面向对象语言（例如Python和Ruby）不同。而第2个假设是对的：java.lang.Class是java.lang.Object的派生类，前者继承自后者。

虽然第1个假设不对，但“鸡蛋问题”仍然存在：在一个已经启动完毕、可以使用的Java对象系统里，必须要有一个java.lang.Class实例对应java.lang.Object这个类；而java.lang.Class是java.lang.Object的派生类，按“一般思维”前者应该要在后者完成初始化之后才可以初始。

事实是：这些相互依赖的核心类型完全可以在“混沌”中一口气都初始化好，然后对象系统的状态才叫做完成了“bootstrap”，后面就可以按照Java对象系统的一般规则去运行。JVM、JavaScript、Python、Ruby等的运行时都有这样的bootstrap过程。**在“混沌”（boostrap过程）里，**JVM可以为对象系统中最重要的一些核心类型先分配好内存空间，让它们进入**[已分配空间]**但**[尚未完全初始化]**状态。

此时这些对象虽然已经分配了空间，但因为状态还不完整所以尚不可使用。然后，通过这些分配好的空间把这些核心类型之间的引用关系串好。到此为止所有动作都由JVM完成，尚未执行任何Java字节码。然后这些核心类型就进入了**[完全初始化]状态**，对象系统就可以开始自我运行下去，也就是可以开始执行Java字节码来进一步完成Java系统的初始化了。

### 1.7.3 equals()方法

**public boolean equals(Object obj)**

equals表示的是对象的内容完全相同，此处的内容多指对象的特征/属性。而==表示的是变量值完全相同（对于基础类型，地址中存储的是值，引用类型则存储指向实际对象的地址）。Object原生的equals()方法内部调用的正是==。

每一个具体的类一般都会重写equals方法，这是因为比较两个对象的标尺不是固定的，比如在String类中是依据字符串内容是否相等来重定义了此标尺含义。如此可以增加类的功能型和实际编码的灵活性。

如上重写equals方法表面上看上去是可以了，实则不然。因为它**破坏了Java中的约定：重写equals()方法必须重写hasCode()方法。**

### 1.7.4 hashcode方法

**public native int hashCode()**

hashCode方法返回一个整形数值，表示该对象的哈希码值。这个整数值是根据某种算法计算出来的一个值，因此它并不是对象所在的物理内存地址，也不一定是对象的逻辑地址。

**hashCode()具有如下约定：**

1).在Java应用程序程序执行期间，对于同一对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的标尺信息未做修改。在Java应用程序的一次执行到另外一次执行，同一对象的hashCode()返回的哈希码无须保持一致。

2).如果两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等。

3).反之，两个对象调用hasCode()返回的哈希码相等，这两个对象不一定相等。

因此，重写equlas()方法必须重写hashCode()方法，以保证此逻辑严格成立，同时可以推理出：hasCode()不相等
=\> equals（）不相等 \<=\> 两个对象不相等。

**hashCode()方法主要用于增强哈希表的性能。**在集合类中，以Set为例，当新加一个对象时，需要判断现有集合中是否已经存在与此对象相等的对象，如果没有hashCode()方法，需要将Set进行一次遍历，并逐一用equals()方法判断两个对象是否相等，此种算法时间复杂度为o(n)。通过借助于hasCode方法，先计算出即将新加入对象的哈希码，然后根据哈希算法计算出此对象的位置，直接判断此位置上是否已有对象即可（注：Set的底层用的是Map的原理实现）。

### 1.7.5 toString方法

**public String toString()**

toString()方法返回该对象的字符串表示，即使没有显式调用，但当我们使用System.out.println(obj)时，其内部也是通过toString()来实现的。

**Object中的默认实现**：

return getClass().getName() + "\@" + Integer.toHexString(hashCode());

### 1.7.6 wait、notify、notifyAll

这个三个方法在多线程中经常被使用（生产者消费者模型），且只能在同步代码块中才能使用。

wait方法被调用后当前线程将立即阻塞，且释放其所持有的同步代码块中的锁，直到被**唤醒或超时或打断后**且**重新获取到锁后**才能继续执行。

**notify方法**用于**随机唤醒**一个正在wait当前对象锁的线程，并让它拿到对象锁。**notifyAll方法**唤醒所有正在wait前对象锁的线程。notify和notifyAll的最主要的区别是：notify只是唤醒一个正在wait当前对象锁的线程，而notifyAll唤醒所有。值得注意的是：notify是本地方法，具体唤醒哪一个线程由虚拟机控制；notifyAll后并不是所有的线程都能马上往下执行，它们只是跳出了wait状态，接下来它们还会是竞争对象锁。

### 1.7.7 finalize方法

**protected void finalize() throws Throwable { }**

Object类中finalize方法被定义成一个空方法。首先，Object中定义finalize方法表明Java中每一个对象都将具有finalize这种行为，其具体调用时机在：JVM准备对此对形象所占用的内存空间进行垃圾回收前，**将被调用**。由此可以看出，此方法并不是需要主动去调用的（虽然可以主动去调用，此时与其他自定义方法无异）。

1.8 Java的异常机制
------------------

### 1.8.1 异常的分类

**Java异常类层次结构图：**

![http://img.my.csdn.net/uploads/201211/27/1354020417_5176.jpg](https://raw.githubusercontent.com/LLLRS/git_resource/master//ad75058182258f5c2c21717e7e79f738.jpg)

在Java中，所有的异常都有一个共同的祖先
**Throwable（可抛出）**。Throwable有两个重要的子类：**Exception（异常）和
Error（错误）**，二者都是 Java 异常处理的重要子类，各自都包含大量子类。

**Error（错误）:**是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时
JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual
MachineError），当 JVM 不再有继续执行操作所需的内存

资源时，将出现
OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。**对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。**

**Exception（异常）**:是程序本身可以处理的异常。Exception 类有一个重要的子类
**RuntimeException**。RuntimeException 类及其子类表示“JVM
常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和
ArrayIndexOutOfBoundException。

**异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。**

通常，Java的异常(包括Exception和Error)分为**可查的异常（checked
exceptions）和不可查的异常（unchecked exceptions）**。

**可查异常（编译器要求必须处置的异常）：**除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。

**不可查异常(编译器不要求强制处置的异常):**包括运行时异常（RuntimeException与其子类）和错误（Error）。

Exception这种异常分两大类**运行时异常和非运行时异常(编译异常)**。程序中应当尽可能去处理这些异常。

**运行时异常：**都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。

**非运行时异常（编译异常）：**是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常。

### 1.8.2 异常处理机制

**在Java应用程序中，异常处理机制为：抛出异常，捕捉异常。**

**抛出异常：**当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。

**捕获异常：**在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception
handler）。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。

**Java规定：对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error**。

### 1.8.3 捕获异常

**捕获异常的关键字有三个：try、catch 和 finally。**

**捕获异常的结构：**

>   try-catch语句

>   try-catch-finally语句

>   try-finally语句

其中catch语句可以出现多次。

**try-catch-finally
规则(**[异常处理语句的语法规则](http://book.51cto.com/art/201009/227791.htm)**）**

1).必须在try之后添加catch或 finally 块。try 块后可同时接 catch 和 finally
块，但至少有一个块。

2).必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try
块之后。

3).一个try块可能有多个catch块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，不会再执行其他的
catch代码块

4).在 try-catch-finally 结构中，可重新抛出异常。

5).除了下列情况，总将执行finally做为结束：JVM 过早终止（调用
System.exit(int)）；在 finally
块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。

**try、catch、finally语句块的执行顺序:**

1).当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；

2).当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行。

3).当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句。

4).finally语句的一些特殊情况：finally语句块一定会被执行。finally中对变量的修改并不会影响返回值。如果finally中有return或者throw语句，方法会直接返回或者抛出异常（一般不推荐这种写法）。

### **1.8.4 抛出异常**

任何Java代码都可以抛出异常，即万物皆可抛（Throwable）。

**throws抛出异常**

如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用throws

子句来声明抛出异常。throws语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是Exception异常类型，则该方法被声明为抛出所有的异常。多个异常可使用逗号分割。throws语句的语法格式为：

**修饰符 返回值 方法名 throws Exception1,Exception2,..,ExceptionN { }**

方法名后的throws Exception1,Exception2,...,ExceptionN
为声明要抛出的异常列表。当方法抛出异常列表的异常时，方法将不对这些类型及其子类类型的异常作处理，而抛向调用该方法的方法，由它去处理。

**throws抛出异常的规则：**

1.如果是不可查异常（unchecked
exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。

2.不用try-catch语句捕获的可查异常（checked
exception）必须用用throws子句声明将它抛出，否则会导致编译错误

3.仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出(异常调用链)。

4．调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。

**使用throw抛出异常**

throw总是出现在函数体中，用来抛出一个Throwable类型的异常。程序会在throw语句后立即终止，它后面的语句执行不到，然后在包含它的所有try块中（可能在上层调用函数中）从里向外寻找含有与其匹配的catch子句的try块。

**该语句的语法格式为：throw new exceptionname;**

如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。

1.9 序列化
----------

### 1.9.1 Java序列化的方式

JDK提供的序列化的方式有两种：**实现序列化接口Serializable或者实现接口Externalizable。可以使用使用
ObjectInputStream 和 ObjectOutputStream 进行对象的读写。**

Externlizable接口继承自**Serializable**接口，但是增加了两个方法:

**writeExternal(ObjectOutput out) 和 readExternal(ObjectInput in)**

writeExternal()方法里定义了哪些属性可以序列化，对象在经过这里就把规定能被序列化的序列化保存文件，不能序列化的不处理，然后在反序列的时候自动调用readExternal()方法，根据序列顺序挨个读取进行反序列，并自动封装成对象返回，然后在测试类接收，就完成了反序列。

序列化过程中被transient修饰的变量和静态变量不会被序列化。序列化保存的是对象

的状态，静态变量属于类的状态，因此**序列化并不保存静态变量**。被反序列化后，被transient
修饰变量的值被设为初始值，如 int 型的是 0，引用类型的是 null。

Java序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。在反序列化时，恢复引用关系，得到的两个对象二者相等，输出
true。该存储规则极大的节省了存储空间。

### 1.9.2 序列化中uuid的作用

**serialVersionUID 用来表明类的不同版本间的兼容性**

具体来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。

当实现java.io.Serializable接口的实体（类）没有显式地定义一个名为serialVersionUID，类型为long的变量时，Java序列化机制会根据编译的class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，只有同一次编译生成的
class才会生成相同的serialVersionUID

### 1.9.3 父类的序列化

一个子类实现了 Serializable
接口，它的父类都没有实现Serializable接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。

具体来说，要想将父类对象也序列化，就需要让父类也实现Serializable
接口。如果父类不实现的话的，就需要有默认的无参的构造函数。 在父类没有实现
Serializable 接口时，虚拟机是不会序列化父对象的。而一个 Java
对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如
int 型的默认是 0，string 型的默认是 null。

### 1.9.4 对敏感字段加密

服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。

在序列化过程中，虚拟机会试图调用对象类里的writeObject和
readObject方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是
ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的
defaultReadObject 方法。用户自定义的 writeObject 和 readObject
方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可

以在实际应用中得到使用，用于敏感字段的加密工作。

除了上述这种方法外，也可以实现Externlizable接口，然后重写**writeExternal和
readExternal方法。**

### 1.9.5 实现序列化的其它方式

**FastJson序列化**

FastJson是由阿里巴巴开发的一个性能很好的Java语言实现的Json解析器和生成器。特点：速度快，测试表明fastjson具有极快的性能，超越任其他的Java
Json Parser。功能强大，完全支持Java
Bean、集合、Map、日期、Enum，支持范型和自省。无依赖，能够直接运行在Java SE
5.0以上版本。

**ProtoBuff序列化**

ProtocolBuffer是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化。适合做数据存储或
RPC
数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。

优点：跨语言；序列化后数据占用空间比JSON小，JSON有一定的格式，在数据量上还有可以压缩的空间。

缺点：它以二进制的方式存储，无法直接读取编辑，除非你有proto定义，否则无法直接读出
Protobuffer的任何内容。

**Thrift序列化**

**Thrift和ProtoBuff**都支持版本向后兼容和向前兼容，但是thrift侧重点是构建跨语言的可伸缩的服务，支持的语言多，同时提供了全套RPC解决方案，可以很方便的直接构建服务，不需要做太多其他的工作。Protobuffer主要是一种序列化机制，在数据序列化上进行性能比较，Protobuffer相对较好。

1.10 Comparable接口和Comparator接口
-----------------------------------

在实际应用中，我们往往有需要比较两个自定义对象大小的地方。而这些自定义对象的比较，就不像简单的整型数据那么简单，它们往往包含有许多的属性，我们一般都是根据这些属性对自定义对象进行比较的。所以Java中要比较对象的大小或者要对对象的集合进行排序，需要通过比较这些对象的某些属性的大小来确定它们之间的大小关系。

一般，Java中通过接口实现两个对象的比较，比较常用就是Comparable接口和Comparator接口。首先类要实现接口，并且使用泛型规定要进行比较的对象所属的类，然后类实现了接口后，还需要实现接口定义的比较方法（compareTo方法或者compare方法），在这些方法中传入需要比较大小的另一个对象，通过选定的成员变量与之比较，如果大于则返回1，小于返回-1，相等返回0。

**Comparable接口和Comparator接口的比较**

1、Comparable和Comparator都是可以用来实现集合中元素的比较、排序的。

2、Comparable是在类内部定义的方法实现的排序，位于java.lang下。

3、Comparator是在类外部实现的排序，位于java.util下。

4、实现Comparable接口需要覆盖compareTo方法，实现Comparator接口需要覆盖compare方法。

总而言之，两种方法各有优劣，用Comparable
简单，只要实现Comparable接口的对象直接就成为一个可以比较的对象，但是需要修改源代码；用Comparator
的好处是不需要修改源代码，而是另外实现一个比较器，当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了。

1.11 接口和抽象类
-----------------

### 1.11.1.接口和抽象类的区别

1．抽象类里可以有构造方法，而接口内不能有构造方法。

2．抽象类中可以有普通成员变量，而接口中不能有普通成员变量。

3．抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是抽象的，不能有非抽象的普通方法。

4．抽象类中的抽象方法的访问类型可以是public
，protected和private，但接口中的抽象方法只能是public类型的，并且默认即为public
abstract类型。

5．抽象类中可以包含静态方法，接口内不能包含静态方法。

6．抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public
static类型，并且默认为public static final类型。

7．一个类可以实现多个接口，但只能继承一个抽象类。

### 1.11.2 抽象类

**抽象类可以声明并定义构造函数**。但是不可以直接创建抽象类的实例，所以构造函数只能通过构造函数链调用（Java中构造函数链指的是从其他构造函数调用一个构造函数）。**如果你不能对抽象类实例化那么构造函数的作用是什么？**它可以用来初始化抽象类内部声明的通用变量，并被各种实现使用。另外，即使你没有提供任何构造函数，编译器将为抽象类添加默认的无参数的构造函数，没有的话你的子类将无法编译，因为在任何构造函数中的第一条语句隐式调用super()，Java中默认超类的构造函数。

**抽象类可以通过使用关键字implements来实现接口。**因为它们是抽象的，所以它们不需要实现所有的方法。好的做法是，提供一个抽象基类以及一个接口来声明类型
。3.

**Java抽象类不能是final的。**将它们声明为final的将会阻止它们被继承，而这正是使用抽象类唯一的方法。它们也是彼此相反的，关键字abstract强制继承类，而关键字final阻止类被扩张。在现实世界中，抽象表示不完备性，而final是用来证明完整性

**抽象类可以没有抽象方法不是强制性的**。但是这样做显得不是很规范。

1.12 枚举类
-----------

枚举类型是Java
5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。

首先来看枚举类的一个实例：

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//2e42fc90ef73e42451879e0b9a252d4d.png)

但是对Day.Class反编译后可以看到：通过关键字enum创建枚举类型在编译后事实上**也是一个类类型而且该类继承自java.lang.Enum类，被final修饰。**

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//1dd966e5c658df450c37c22248cdbd87.png)

### 1.12.1 Enum抽象类

Enum是所有 Java
语言枚举类型的公共基本类（注意Enum是抽象类），以下是它的常见方法：

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//915ea2abcb7b65aee9afd5b558b4c496.png)

**ordinal()方法：**该方法获取的是枚举变量在枚举类中声明的顺序，下标从0开始，如日期中的MONDAY在第一个位置，那么MONDAY的ordinal值就是0，如果MONDAY的声明位置发生变化，那么ordinal方法获取到的值也随之变化。

**compareTo(E
o)方法**：比较枚举的大小，内部实现是根据每个枚举的ordinal值大小进行比较的。注意：该方法是被final修饰。

此外，Enum类内部会有一个构造函数，该构造函数只能有编译器调用。

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//8a23cd21556d7fd0fa4fdb25f2e00b5b.png)

编译器生成的Values方法与ValueOf方法都**是static方法**，values()方法的作用就是获取枚举类中的所有变量，并作为数组返回，而valueOf(String
name)方法则是根据名称获取枚举变量。

**Enum中的定义的方法只有toString方法没有使用final修饰。**

### 1.12.2 枚举与单例模式

![](https://raw.githubusercontent.com/LLLRS/git_resource/master//a873fc8248fead87669d4c68898c475a.png)

通时，可以像常规类一样编写enum类，为其添加变量和方法，访问方式也更简单，使用**SingletonEnum.INSTANCE进行访问**，这样也就避免调用getInstance方法，更重要的是使用枚举单例的写法，完全不用考虑序列化和反射的问题（懒汉式、饿汉式、静态内部类和双重检查都有这个问题）。

[更详细的分析看这篇文章。](https://blog.csdn.net/javazejian/article/details/71333103)

1.13 内部类
-----------

内部类是指在一个外部类的内部再定义一个类。**内部类作为外部类的一个成员**，并且依附于外部类而存在的。**内部类可为静态，可用protected和private修饰**（而外部类只能使用public和缺省的包访问权限）。

内部类主要有以下几类：成员内部类、局部内部类、静态内部类、匿名内部类。

局部内部类就是写在方法里的类，只在方法执行时加载，一次性使用。匿名内部类是局部内部类的一种特殊形式。

### 1.13.1 内部类的共性

1.
内部类一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和\$符号。

2. 类不能用普通的方式访问。

3.
**声明成静态的，就不能随便的访问外部类的成员变量了，此时内部类只能访问外部类的静态成员变量。**

4. 不能直接访问内部类的的成员，但可以通过内部类对象来访问。

5.
内部类是延时加载的，不论是静态内部类还是非静态内部类都是在第一次使用时才会被加载。

内部类是外部类的一个成员，因此内部类可以自由地访问外部类的成员变量，无论是否是private的。因为当某个外围类的对象创建内部类的对象时，此内部类会捕获一个隐式引

用，它引用了实例化该内部对象的外围类对象。通过这个指针，可以访问外围类对象的全部状态。

通过反编译内部类的字节码，分析之后主要是通过以下几步做到的：

1．编译器自动为内部类添加一个成员变量，这个成员变量的类型和外部类的类型相同，
这个成员变量就是指向外部类对象的引用。

2．编译器自动为内部类的构造方法添加一个参数，参数的类型是外部类的类型，
在构造方法内部使用这个参数为1中添加的成员变量赋值。

3．在调用内部类的构造函数初始化内部类对象时，会默认传入外部类的引用。

### 1.13.2 静态内部类与普通内部类的区别

**静态内部类不持有外部类的引用**

在普通内部类中，可以直接访问外部类的属性、方法，即使是private类型也可以访问，这是因为内部类持有一个外部类的引用，可以自由访问。而静态内部类，则只可以访问外部类的静态方法和静态属性（如果是private权限也能访问，这是由其代码位置所决定的），其他则不能访问。

**静态内部类不依赖外部类**

普通内部类与外部类之间是相互依赖的关系，内部类实例不能脱离外部类实例，也就是说它们会同生同死，一起声明，一起被垃圾回收器回收。而静态内部类是可以独立存在的，即使外部类消亡了，静态内部类还是可以存在的。

**普通内部类不能声明static的方法和变量**

普通内部类不能声明static的方法和变量，注意这里说的是变量，常量（也就是final
static修饰的属性）还是可以的。普通内部类之所以叫做成员
就是说它类实例的一部分，不是类的一部分。

### 1.13.3 匿名内部类

匿名内部类就是没有名字的内部类。

匿名内部类不能定义任何静态成员、方法。

匿名内部类中的方法不能是抽象的。

匿名内部类必须实现接口或抽象父类的所有抽象方法。

匿名内部类访问的外部类成员变量或成员方法必须用static修饰

**匿名内部类不能定义构造器**。

**匿名内部类不能是抽象类，必须实现接口或抽象父类的所有抽象方法**。

当匿名内部类和外部类有同名变量（方法）时，默认访问的是匿名内部类的变量（方法），要访问外部类的变量（方法）则需要加上外部类的类名。

如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。这是因为内部类实际上是通过外部类的

一个引用来使用这个参数的，如果不用final修饰使得这个形参不可变，则外部类和内部类的值可能会不一样。

