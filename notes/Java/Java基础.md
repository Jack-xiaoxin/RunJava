## 1  Java的数据类型
### 1.1  8种基本数据类型
布尔型: boolean

字符型:char

整数型:byte, short, int, long

浮点数型:float, double

![image](https://raw.githubusercontent.com/LLLRS/git_resource/master/image001.png)
 
### 1.2  装箱和拆箱
自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。
原始类型: boolean，char，byte，short，int，long，float，double
封装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double
### 1.3  String转为int型，判断能不能转？如何转？
可以转（Integer.parseInt(s)），但是可能会出现NumberFormatException异常，原因可能有以下几点：
* 输入的字符串中含有字母。
* 输入为空。
* 输入超出int上限时，这个时候可以考虑用Long.parseLong(s)转换为long。


### 1.4 静态变量和全局变量的区别
**局部变量**：在方法内定义的变量称为“局部变量”或“临时变量”，方法结束后局部变量占用的内存将被释放。
**成员变量**：在类体的变量部分中定义的变量，也称为字段。
**非静态成员变量，**又称为属性，对该类不同的对象来说，属性是不同的。
**静态成员变量**，一个类中只有一个该变量，该类不同的对象共享同一个静态成员变量

## 2  Java的基本特征
### 2.1  Java的四个基本特征
**抽象**：抽象是将一类的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两个方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。
**继承**：继承是从已有类得到的继承信息创建新类的过程。提供继承信息放入类被成为父类，得到继承信息的类被称为子类。Java的继承通过extends关键字来实现单继承，接口可以实现多继承。
**封装**：把对象的属性和行为（方法）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。在Java中，对于对象的内部属性一般用private来实现隐藏，并通过set和get方法对外提供访问接口。
**多态**：不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态。多态存在的三个必要条件：要有继承、要有重写、父类引用指向子类对象。

### 2.2  方法重写和方法重载
重写是由于继承关系中的子类有一个和父类同名同参数的方法，会覆盖掉父类的方法。
重载是因为一个同名方法可以传入多个参数组合。同名方法如果参数相同，即使返回值不同也是不能同时存在的，编译会出错。两者都是Java中多态性一个的一个体现，方法重写是父类与子类之间多态性的体现，而方法重载主要是类内部多态性的一个体现。
从JVM实现的角度来看，重写又叫运行时多态，编译时看不出子类调用的是哪个方法，但是运行时操作数栈会先根据子类的引用去子类的类信息中查找方法，找不到的话再到父类的类信息中查找方法。而重载则是编译时多态，因为编译期就可以确定传入的参数组合，决定调用的具体方法是哪一个了。
Java中static方法不能被重写，因为方法重写是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
Java中也不可以重写private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。

### 2.3  Java创建对象的四种方法
- 使用new关键字
- 使用Class类的newInstance方法（反射）
- 使用clone方法
- 反序列化

### 2.4  值传递与引用传递
值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。
Java中只有是值传递的，对于基本类型来说，传递的就是值。对于一个具体的对象来说，值的内容是对象的引用，这样在函数中改变这个地址的值（例如重新new一个对象）实际上不会影响到原对象，但是如果修改这个地址指向的内容，就会对原对象产生影响。

### 2.5  C++/JAVA/C的区别
C语言是面向过程的语言，Java与C++都是面向对象的语言，都使用了面向对象的思想（封装、继承、多态），由于面向对象由许多非常好的特性（继承、组合等），因此二者有很好的可重用性。

**主要不同点：**
1、Java为解释性语言，其运行过程为：程序源代码经过Java编译器编译成字节码，然后由JVM解释执行。而C/C++为编译型语言，源代码经过编译和链接后生成可执行的二进制代码，可直接执行。因此Java的执行速度比C/C++慢，但Java能够跨平台执行，C/C++不能。
2、Java是纯面向对象语言，所有代码（包括函数、变量）必须在类中实现，除基本数据类型（包括int、float等）外，所有类型都是类。此外，Java语言中不存在全局变量或者全局函数，而C++可以定义全局变量和全局函数。
3、在Java中不可能直接操作对象本身，所有的对象都由一个引用指向，必须通过这个引用才能访问对象本身，包括获取成员变量的值，改变对象的成员变量，调用对象的方法等。而在C++中存在引用，对象和指针三个东西，这三个东西都可以访问对象。
4、与C++语言相比，Java语言不支持多重继承，但是Java语言引入了接口的概念，可以同时实现多个接口。由于接口也有多态特性，因此Java语言中可以通过实现多个接口来实现与C++语言中多重继承类似的目的。
5、在C++语言中，需要开发人员去管理内存的分配（包括申请和释放），而Java语言提供了垃圾回收器来实现垃圾的自动回收，不需要程序显示地管理内存的分配。
6、C++有goto，Java没有goto。但是Java提供了一种类似的跳转机制：标签。用法 label：。（break label ，continue label）

## 3  String类相关
### 3.1  String类为什么是不可变的
首先看下JDK中String类的定义：
 
从中可以看出： String类被final关键字修饰，所以不能被继承。其次String类的底层是一个私有的被final修饰的char型数组，这个数组指向的堆地址不能被修改。（理论上char数组里的值是可以改变的，但是String并没有提供修改的方法，但是但是实际上这个私有的char型数组的值也是可以通过反射进行修改的）。
String提供的一些方法如substring， replace， replaceAll， toLowerCase等，这些方法的返回都是一个新的String对象(修改的过
程中复制了一份新的char数组)。
 
### 3.2  String字符串的创建方式
String str = “hello”;
这种方法创建字符串 对象的时候，JVM首先会检查字符串常量池中是否存在该字符串的对象，如果已经存在，那么就不会在字符串常量池中再创建了，直接返回该字符串常量池内存中的内存地址。如果该字符串还不存在字符串常量池中，那么就会在字符串常量池中先创建该字符串的对象，然后在返回其内存地址。
String str = new String(“hello”);
这种方式创建字符串对象的时候 ，JVM首先会检查字符串常量池中是否存在“hello”的字符串，如果已经存在，则不会在字符串常量池中创建了，如果还没有存在，那么就会在字符串常量池中创建“hello”字符串对象。然后还会去堆内存中再创建一份字符串的对象（凡是以new关键字创建的对象，JVM都会在堆内存中开辟一个新的空间，创建一个新的对象），把字符串常量池中的“hello”字符串内容拷贝至内存中的字符串对象，然后返回堆内存中字符串对象的内存地址。
### 3.3  String的intern方法
String的intern方法：用来返回常量池中的某字符串，如果常量池中已经存在该字符串，则直接返回常量池中该对象的引用。否则，在常量池中加入该对象，然后返回引用。在jdk1.7之前，字符串常量存储在方法区的PermGen Space。在jdk1.7之后，字符串常量重新被移到了堆中，且如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。
如果在程序中用 + 号来连接字符串，实际上都是通过StringBuilder来实现的，所以如果大量用到+号，可能会导致效率较低。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。
### 3.4  为什么重写equals方法，就必须重写hashcode方法
答：equals和hashcode都来自于Object类，Object类中的equals方法比较两个引用类型的对象时，只有两个对象的地址相同时，才返回true。hashCode()返回的是对象的哈希码值。这个哈希码的作用是确定该对象在哈希表中的索引位置。String类重写了equals方法和hashcode方法。

首先equals与hashcode间的关系是这样的：
1、如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同。
2、如果两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false)。 
由于为了提高程序的效率才实现了hashcode方法，先进行hashcode的比较，如果不同，那没就不必在进行equals的比较了，这样就大大减少了equals比较的次数，这对比需要比较的数量很大的效率提高是很明显的，一个很好的例子就是在集合中的使用。
所以为什么必须要重写hashcode方法，其实简单的说就是为了保证同一个对象，保证在equals相同的情况下hashcode值必定相同，如果重写了equals而未重写hashcode方法，可能就会出现两个没有关系的对象equals相同的（因为equal都是根据对象的特征进行重写的），但hashcode确实不相同的。
### 3.6  String、StringBuilder、StringBuffer的比较
* String 是不可变的，StringBuffer、StringBuilder是可变的。
* String 、StringBuffer是线程安全的，StringBuilder是线程不安全的 （StringBuffer的append操作用了synchronized）。
* String对象串联的效率最慢，单线程下字符串的串联用StringBuilder，多线程下字符串的串联用StrngBuffer。
* StringBuilder、StringBuffer 的方法都会调用AbstractStringBuilder 中的公共方法，如super.append(...)。只是StringBuffer 会在方法上加synchronized 关键字，进行同步。最后，如果程序不是多线程的，那么使用StringBuilder 效率高于StringBuffer。

## 4  Java的反射机制
JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。
通过反射可以访问一个对象的私有的属性和方法。反射通常用在注解、Spring配置文件、动态代理中。
反射的底层主要是通过Class类来实现的。
## 5  Java关键字
### 5.1  修饰符
 
不写时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。
不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。
### 5.2  final关键字
final关键字主要用在三个地方：变量、方法、类。
变量：对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
方法：使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。
类：当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。
### 5.3  static关键字
static关键字主要用在三个地方:
修饰成员变量和成员方法：被 static修饰的成员变量和成员方法属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以通过类名调用。
修饰代码块：静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。 该类不管创建多少对象，静态代码块只执行一次。
修饰类（只能用于内部类）：静态内部类没有外部类引用，不能使用任何外部类的非static成员变量和方法。静态内部类延迟加载，只有用到的时候才会被创建，且只会被创建一次。

静态方法与非静态方法
静态方法属于类，非静态方法属于对象。静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法，非静态方法则无此限制。
静态代码块与非静态代码块
相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。
不同点： 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new自动执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。

非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化。

this关键字用于引用类的当前实例。
super关键字用于从子类访问父类的变量和方法。

static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
